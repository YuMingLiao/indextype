{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE UndecidableSuperClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeOperators #-}

{-|
Module      : Control.IndexT
Description : Type functions for getting the type at a particular index of another type, and some handy constraints.
Copyright   : Clinton Mead, 2017
License     : MIT
Maintainer  : clintonmead@gmail.com
Stability   : experimental
Portability : GHC

This module is useful for dealing with for what I have called "indexed types". This is perhaps not a great choice of
name (alternative suggestions welcome) but basically I'm talking about types where you can "index" them like an array.
A tuple, is a good example. This module gives you a type function that allows you to get the type of the say, third
element of a tuple.

Building on this, occasionally you'll want to write a constraint like this:

> t ~ (t1,t2)

i.e. @t@ is a pair. But if @t1@ and @t2@ are not in scope, GHC will complain.

This module contains some constraints that allow you to make constraints like "@t@ is a pair".

All of what I've said above is also defined for functions, and the type families are open, so you can extend this
module for your own data types.

More detailed usage information is in the documentation below.

Note that much of this code was wasn't actually hand written but generated by another Haskell program.
You can get this program from the "codegen" directory of the distribution in github.

Currently this library deals with tuples up to length 15 and functions with up to 15 arguments.
I can fairly easily generate code to deal with larger tuples and functions, tell me if you need this.
-}

module Control.IndexT (
  IndexT,
  ResultT,
  TupleN,
  TupleConstraint,
  HomoTupleConstraint,
  IsTuple,
  IsHomoTuple,
  FuncN,
  FuncConstraint,
  HomoFuncConstraint,
  IsFunc,
  IsHomoFunc
  ) where

import GHC.TypeLits (Nat, type (-))
import GHC.Exts (Constraint)
import Data.Functor.Identity (Identity)

{-|
'IndexT' is the core type family of this module. @IndexT n a@ gets the type of the "nth" element of @a@.
In this module, 'IndexT' is defined on tuples and functions, and is zero based.

So

> IndexT 0 (a, b, c) == a

and

> IndexT 0 (a -> b -> c) == a

Note the following:

> IndexT 1 (a -> b -> c) == b
> IndexT 2 (a, b, c) == c

but...

> IndexT 2 (a -> b -> c) /= c -- (it's actually not defined)

This is because the way functions are defined. Consider a function of three arguments:

> f :: a -> b -> c -> d

For this function, we want:

> IndexT 2 (a -> b -> c -> d) == c

But if we defined 'IndexT' like the following:

> IndexT 2 (a -> b -> c) = c

Then we would find that:

> IndexT 2 (a -> b -> c -> d) == IndexT 2 (a -> b -> (c -> d)) == (c -> d)

Which is not right. For this reason, 'IndexT' can not get the "result" type of functions, you'll need to use 'ResultT' for that.
-}
type family IndexT (i :: Nat) a
type instance IndexT 0 (Identity a) = a
type instance IndexT 0 (a, _) = a
type instance IndexT 1 (_, a) = a
type instance IndexT 0 (a, _, _) = a
type instance IndexT 1 (_, a, _) = a
type instance IndexT 2 (_, _, a) = a
type instance IndexT 0 (a, _, _, _) = a
type instance IndexT 1 (_, a, _, _) = a
type instance IndexT 2 (_, _, a, _) = a
type instance IndexT 3 (_, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _) = a
type instance IndexT 3 (_, _, _, a, _) = a
type instance IndexT 4 (_, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _) = a
type instance IndexT 5 (_, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a, _) = a
type instance IndexT 7 (_, _, _, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _, _, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a, _, _) = a
type instance IndexT 7 (_, _, _, _, _, _, _, a, _) = a
type instance IndexT 8 (_, _, _, _, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _, _, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _, _, _, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a, _, _, _) = a
type instance IndexT 7 (_, _, _, _, _, _, _, a, _, _) = a
type instance IndexT 8 (_, _, _, _, _, _, _, _, a, _) = a
type instance IndexT 9 (_, _, _, _, _, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _, _, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _, _, _, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _, _, _, _, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a, _, _, _, _) = a
type instance IndexT 7 (_, _, _, _, _, _, _, a, _, _, _) = a
type instance IndexT 8 (_, _, _, _, _, _, _, _, a, _, _) = a
type instance IndexT 9 (_, _, _, _, _, _, _, _, _, a, _) = a
type instance IndexT 10 (_, _, _, _, _, _, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _, _, _, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _, _, _, _, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _, _, _, _, _, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a, _, _, _, _, _) = a
type instance IndexT 7 (_, _, _, _, _, _, _, a, _, _, _, _) = a
type instance IndexT 8 (_, _, _, _, _, _, _, _, a, _, _, _) = a
type instance IndexT 9 (_, _, _, _, _, _, _, _, _, a, _, _) = a
type instance IndexT 10 (_, _, _, _, _, _, _, _, _, _, a, _) = a
type instance IndexT 11 (_, _, _, _, _, _, _, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _, _, _, _, _, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _, _, _, _, _, _, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a, _, _, _, _, _, _) = a
type instance IndexT 7 (_, _, _, _, _, _, _, a, _, _, _, _, _) = a
type instance IndexT 8 (_, _, _, _, _, _, _, _, a, _, _, _, _) = a
type instance IndexT 9 (_, _, _, _, _, _, _, _, _, a, _, _, _) = a
type instance IndexT 10 (_, _, _, _, _, _, _, _, _, _, a, _, _) = a
type instance IndexT 11 (_, _, _, _, _, _, _, _, _, _, _, a, _) = a
type instance IndexT 12 (_, _, _, _, _, _, _, _, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _, _, _, _, _, _, _, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a, _, _, _, _, _, _, _) = a
type instance IndexT 7 (_, _, _, _, _, _, _, a, _, _, _, _, _, _) = a
type instance IndexT 8 (_, _, _, _, _, _, _, _, a, _, _, _, _, _) = a
type instance IndexT 9 (_, _, _, _, _, _, _, _, _, a, _, _, _, _) = a
type instance IndexT 10 (_, _, _, _, _, _, _, _, _, _, a, _, _, _) = a
type instance IndexT 11 (_, _, _, _, _, _, _, _, _, _, _, a, _, _) = a
type instance IndexT 12 (_, _, _, _, _, _, _, _, _, _, _, _, a, _) = a
type instance IndexT 13 (_, _, _, _, _, _, _, _, _, _, _, _, _, a) = a
type instance IndexT 0 (a, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 1 (_, a, _, _, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 2 (_, _, a, _, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 3 (_, _, _, a, _, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 4 (_, _, _, _, a, _, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 5 (_, _, _, _, _, a, _, _, _, _, _, _, _, _, _) = a
type instance IndexT 6 (_, _, _, _, _, _, a, _, _, _, _, _, _, _, _) = a
type instance IndexT 7 (_, _, _, _, _, _, _, a, _, _, _, _, _, _, _) = a
type instance IndexT 8 (_, _, _, _, _, _, _, _, a, _, _, _, _, _, _) = a
type instance IndexT 9 (_, _, _, _, _, _, _, _, _, a, _, _, _, _, _) = a
type instance IndexT 10 (_, _, _, _, _, _, _, _, _, _, a, _, _, _, _) = a
type instance IndexT 11 (_, _, _, _, _, _, _, _, _, _, _, a, _, _, _) = a
type instance IndexT 12 (_, _, _, _, _, _, _, _, _, _, _, _, a, _, _) = a
type instance IndexT 13 (_, _, _, _, _, _, _, _, _, _, _, _, _, a, _) = a
type instance IndexT 14 (_, _, _, _, _, _, _, _, _, _, _, _, _, _, a) = a
type instance IndexT 0 (a -> _) = a
type instance IndexT 1 (_ -> a -> _) = a
type instance IndexT 2 (_ -> _ -> a -> _) = a
type instance IndexT 3 (_ -> _ -> _ -> a -> _) = a
type instance IndexT 4 (_ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 5 (_ -> _ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 6 (_ -> _ -> _ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 7 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 8 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 9 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 10 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 11 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 12 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a -> _) = a
type instance IndexT 13 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a -> _) = a

{-|
'ResultT' is used to get the result type of functions, which 'IndexT' can not be used for as discussed in
it's documentation.

@ResultT n t@ gets the result of @t@ treated as an @n@ argument function. For example:

> ResultT 2 (a -> b -> c) == c

note that:

> ResultT 2 (a -> b -> c -> d) == c -> d

which makes sense, as the result of applying two arguments to this function is @(c -> d)@.
-}
type family ResultT (n :: Nat) a
type instance ResultT 0 (a) = a
type instance ResultT 1 (_ -> a) = a
type instance ResultT 2 (_ -> _ -> a) = a
type instance ResultT 3 (_ -> _ -> _ -> a) = a
type instance ResultT 4 (_ -> _ -> _ -> _ -> a) = a
type instance ResultT 5 (_ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 6 (_ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 7 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 8 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 9 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 10 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 11 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 12 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 13 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 14 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a
type instance ResultT 15 (_ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> a) = a

{-|
'TupleN' seems a bit weird, but it's an important part of defining constraints that allow one to say "@t@ is a pair"
in 'TupleConstraint'.
-}
type family TupleN (n :: Nat) a
type instance TupleN 0 a = ()
type instance TupleN 1 a = Identity a
type instance TupleN 2 a = (IndexT 0 a, IndexT 1 a)
type instance TupleN 3 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a)
type instance TupleN 4 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a)
type instance TupleN 5 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a)
type instance TupleN 6 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a)
type instance TupleN 7 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a)
type instance TupleN 8 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a, IndexT 7 a)
type instance TupleN 9 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a, IndexT 7 a, IndexT 8 a)
type instance TupleN 10 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a, IndexT 7 a, IndexT 8 a, IndexT 9 a)
type instance TupleN 11 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a, IndexT 7 a, IndexT 8 a, IndexT 9 a, IndexT 10 a)
type instance TupleN 12 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a, IndexT 7 a, IndexT 8 a, IndexT 9 a, IndexT 10 a, IndexT 11 a)
type instance TupleN 13 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a, IndexT 7 a, IndexT 8 a, IndexT 9 a, IndexT 10 a, IndexT 11 a, IndexT 12 a)
type instance TupleN 14 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a, IndexT 7 a, IndexT 8 a, IndexT 9 a, IndexT 10 a, IndexT 11 a, IndexT 12 a, IndexT 13 a)
type instance TupleN 15 a = (IndexT 0 a, IndexT 1 a, IndexT 2 a, IndexT 3 a, IndexT 4 a, IndexT 5 a, IndexT 6 a, IndexT 7 a, IndexT 8 a, IndexT 9 a, IndexT 10 a, IndexT 11 a, IndexT 12 a, IndexT 13 a, IndexT 14 a)

{-|
Like 'TupleN', but for functions.
-}
type family FuncN (n :: Nat) a
type instance FuncN 0 a = a
type instance FuncN 1 a = IndexT 0 a -> ResultT 1 a
type instance FuncN 2 a = IndexT 0 a -> IndexT 1 a -> ResultT 2 a
type instance FuncN 3 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> ResultT 3 a
type instance FuncN 4 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> ResultT 4 a
type instance FuncN 5 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> ResultT 5 a
type instance FuncN 6 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> ResultT 6 a
type instance FuncN 7 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> ResultT 7 a
type instance FuncN 8 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> IndexT 7 a -> ResultT 8 a
type instance FuncN 9 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> IndexT 7 a -> IndexT 8 a -> ResultT 9 a
type instance FuncN 10 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> IndexT 7 a -> IndexT 8 a -> IndexT 9 a -> ResultT 10 a
type instance FuncN 11 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> IndexT 7 a -> IndexT 8 a -> IndexT 9 a -> IndexT 10 a -> ResultT 11 a
type instance FuncN 12 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> IndexT 7 a -> IndexT 8 a -> IndexT 9 a -> IndexT 10 a -> IndexT 11 a -> ResultT 12 a
type instance FuncN 13 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> IndexT 7 a -> IndexT 8 a -> IndexT 9 a -> IndexT 10 a -> IndexT 11 a -> IndexT 12 a -> ResultT 13 a
type instance FuncN 14 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> IndexT 7 a -> IndexT 8 a -> IndexT 9 a -> IndexT 10 a -> IndexT 11 a -> IndexT 12 a -> IndexT 13 a -> ResultT 14 a
type instance FuncN 15 a = IndexT 0 a -> IndexT 1 a -> IndexT 2 a -> IndexT 3 a -> IndexT 4 a -> IndexT 5 a -> IndexT 6 a -> IndexT 7 a -> IndexT 8 a -> IndexT 9 a -> IndexT 10 a -> IndexT 11 a -> IndexT 12 a -> IndexT 13 a -> IndexT 14 a -> ResultT 15 a

{-|
To best explain this, lets consider the particular example @TupleConstraint 2@.

As @TupleN 2 t = (IndexT 0 t, IndexT 1 t)@ we get:

> TupleConstraint 2 t = t ~ (IndexT 0 t, IndexT 1 t)

What does this say? Well, firstly, as @t ~ (IndexT 0 t, IndexT 1 t)@, it must be a pair at least.

What are the elements of the pair? Well, the first element of @t@ is @IndexT 0 t@.

And what's @IndexT 0 t@ defined as? The first element of @t@.

So we know that the first element of @t@ is well, the first element of @t@.

Which tells us nothing at all.

We can go through the same argument with the second element of @t@.

So all we know after this is that @t@ is a pair. @TupleConstraint 2 t@ is the same as saying @t@ is a pair.

So @TupleConstraint n t@ basically says @t@ is a n-tuple.
-}
type TupleConstraint (n :: Nat) a = a ~ TupleN n a

{-|
Like 'TupleConstraint', but for functions.
-}
type FuncConstraint (n :: Nat) a = a ~ FuncN n a

{-|
'HomoTupleConstraint' simply further constrains 'TupleConstraint' so that all the elements are the same.

So @HomoTupleConstraint 3 t@ basically says @t ~ (u,u,u)@ for some @u@,
-}
type family HomoTupleConstraint (n :: Nat) a :: Constraint
type instance HomoTupleConstraint 0 a = (TupleConstraint 0 a)
type instance HomoTupleConstraint 1 a = (TupleConstraint 1 a)
type instance HomoTupleConstraint 2 a = (TupleConstraint 2 a, IndexT 0 a ~ IndexT 1 a)
type instance HomoTupleConstraint 3 a = (TupleConstraint 3 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a)
type instance HomoTupleConstraint 4 a = (TupleConstraint 4 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a)
type instance HomoTupleConstraint 5 a = (TupleConstraint 5 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a)
type instance HomoTupleConstraint 6 a = (TupleConstraint 6 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a)
type instance HomoTupleConstraint 7 a = (TupleConstraint 7 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a)
type instance HomoTupleConstraint 8 a = (TupleConstraint 8 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a)
type instance HomoTupleConstraint 9 a = (TupleConstraint 9 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a)
type instance HomoTupleConstraint 10 a = (TupleConstraint 10 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a)
type instance HomoTupleConstraint 11 a = (TupleConstraint 11 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a)
type instance HomoTupleConstraint 12 a = (TupleConstraint 12 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a, IndexT 10 a ~ IndexT 11 a)
type instance HomoTupleConstraint 13 a = (TupleConstraint 13 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a, IndexT 10 a ~ IndexT 11 a, IndexT 11 a ~ IndexT 12 a)
type instance HomoTupleConstraint 14 a = (TupleConstraint 14 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a, IndexT 10 a ~ IndexT 11 a, IndexT 11 a ~ IndexT 12 a, IndexT 12 a ~ IndexT 13 a)
type instance HomoTupleConstraint 15 a = (TupleConstraint 15 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a, IndexT 10 a ~ IndexT 11 a, IndexT 11 a ~ IndexT 12 a, IndexT 12 a ~ IndexT 13 a, IndexT 13 a ~ IndexT 14 a)

{-|
Like 'HomoTupleConstraint', but for functions, where all arguments and the result type are the same.
-}
type family HomoFuncConstraint (n :: Nat) a :: Constraint
type instance HomoFuncConstraint 0 a = (FuncConstraint 0 a)
type instance HomoFuncConstraint 1 a = (FuncConstraint 1 a, ResultT 1 a ~ IndexT 0 a)
type instance HomoFuncConstraint 2 a = (FuncConstraint 2 a, ResultT 2 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a)
type instance HomoFuncConstraint 3 a = (FuncConstraint 3 a, ResultT 3 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a)
type instance HomoFuncConstraint 4 a = (FuncConstraint 4 a, ResultT 4 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a)
type instance HomoFuncConstraint 5 a = (FuncConstraint 5 a, ResultT 5 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a)
type instance HomoFuncConstraint 6 a = (FuncConstraint 6 a, ResultT 6 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a)
type instance HomoFuncConstraint 7 a = (FuncConstraint 7 a, ResultT 7 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a)
type instance HomoFuncConstraint 8 a = (FuncConstraint 8 a, ResultT 8 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a)
type instance HomoFuncConstraint 9 a = (FuncConstraint 9 a, ResultT 9 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a)
type instance HomoFuncConstraint 10 a = (FuncConstraint 10 a, ResultT 10 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a)
type instance HomoFuncConstraint 11 a = (FuncConstraint 11 a, ResultT 11 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a)
type instance HomoFuncConstraint 12 a = (FuncConstraint 12 a, ResultT 12 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a, IndexT 10 a ~ IndexT 11 a)
type instance HomoFuncConstraint 13 a = (FuncConstraint 13 a, ResultT 13 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a, IndexT 10 a ~ IndexT 11 a, IndexT 11 a ~ IndexT 12 a)
type instance HomoFuncConstraint 14 a = (FuncConstraint 14 a, ResultT 14 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a, IndexT 10 a ~ IndexT 11 a, IndexT 11 a ~ IndexT 12 a, IndexT 12 a ~ IndexT 13 a)
type instance HomoFuncConstraint 15 a = (FuncConstraint 15 a, ResultT 15 a ~ IndexT 0 a, IndexT 0 a ~ IndexT 1 a, IndexT 1 a ~ IndexT 2 a, IndexT 2 a ~ IndexT 3 a, IndexT 3 a ~ IndexT 4 a, IndexT 4 a ~ IndexT 5 a, IndexT 5 a ~ IndexT 6 a, IndexT 6 a ~ IndexT 7 a, IndexT 7 a ~ IndexT 8 a, IndexT 8 a ~ IndexT 9 a, IndexT 9 a ~ IndexT 10 a, IndexT 10 a ~ IndexT 11 a, IndexT 11 a ~ IndexT 12 a, IndexT 12 a ~ IndexT 13 a, IndexT 13 a ~ IndexT 14 a)

{-|
GHC does not allow you to partially apply type families (or any type declaration for that matter).
So if you have a type of @* -> Constraint@ you can't pass @TupleConstraint 2@, because 'TupleConstraint' is partially
applied and this is not allowed.

But you can partially apply classes.

So 'IsTuple' is basically the same as 'TupleConstraint' except that it's a class, not a type family.
-}
class (TupleConstraint n a) => IsTuple n a
instance (TupleConstraint n a) => IsTuple n a

{-|
The version of 'IsTuple' for homogenous tuples (i.e. all the same type.
-}
class (HomoTupleConstraint n a) => IsHomoTuple n a
instance (HomoTupleConstraint n a) => IsHomoTuple n a

{-|
Like 'IsTuple', but for functions.
-}
class (FuncConstraint n a) => IsFunc n a
instance (FuncConstraint n a) => IsFunc n a

{-|
Like 'IsHomoTuple', but for functions.
-}
class (HomoFuncConstraint n a) => IsHomoFunc n a
instance (HomoFuncConstraint n a) => IsHomoFunc n a
